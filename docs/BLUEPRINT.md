# Project Overview

This project aims to create a Scala 3 functional + ZIO 2 rework of the “99 Bottles” book. The goal is to keep every code snippet compiled, formatted, and auto-extracted from the source code, ensuring a high level of quality and maintainability.

# Project guidelines

---

# 1. Guardrails: scope, attribution, and licensing

- Use the original book for ideas, not text. Rework concepts (Shameless Green, Flocking Rules, OCP, LSP, Law of Demeter, testing strategy, etc.) but avoid copying prose or large code blocks verbatim. Keep excerpts tiny and transform them into your own words.
- Anchor posts/chapters with an attribution line like: "Inspired by 99 Bottles of OOP (2nd ed.)" and short citations to the relevant idea (for example: Shameless Green, Flocking Rules, LSP, Factories spectrum, Law of Demeter, testing strategy).

---

# 2. Repository layout (mono-repo)

Suggested layout:

```text
99bottles-scala/
├─ build.sbt
├─ project/               # sbt plugins, version pinning
├─ scalafmt.conf
├─ scripts/               # Ruby tooling only
│  ├─ extract_snippets.rb
│  ├─ check_regions.rb
│  ├─ post_pipeline.rb
│  └─ utilities/
├─ modules/
│  ├─ functional/         # Scala 3 purely-functional implementation(s)
│  │  ├─ src/main/scala/...
│  │  └─ src/test/scala/...
│  ├─ zio/                # ZIO 2.x effect-oriented implementation(s)
│  │  ├─ src/main/scala/...
│  │  └─ src/test/scala/...
│  └─ shared/             # shared domain & test data (pure Scala)
│     ├─ src/main/scala/...
│     └─ src/test/scala/...
├─ docs/                  # the “book” (Markdown), built from source regions
│  ├─ 00-preface.md
│  ├─ 01-shameless-green.md
│  ├─ 02-tdd-basics.md
│  ├─ 03-flocking-rules.md
│  ├─ 04-immutability-lsp.md
│  ├─ 05-open-closed.md
│  ├─ 06-factories-functional.md
│  ├─ 07-programming-aesthetic.md
│  ├─ 08-testing-strategy.md
│  └─ _includes/          # snippet files generated by scripts/
├─ posts/                 # X/LinkedIn posts as Markdown (frontmatter)
│  ├─ 2025-01-foo.md
│  └─ media/
├─ .github/workflows/     # Actions
│  ├─ ci.yml
│  ├─ docs.yml
│  ├─ lint.yml
│  ├─ posts.yml
│  └─ bot.yml
└─ n8n/                   # exportable n8n workflows (JSON) + docs
	├─ review-agent.json
	├─ post-agent.json
	└─ README.md
```

Conventions

- Only Scala in `/modules` and in code fences inside `docs/`.
- Only Ruby in `/scripts` and related workflow helpers.
- GitHub Actions YAML and n8n JSON are allowed as configuration files.
- Every code fence in `docs/` and `posts/` should be generated from real source via Ruby extractor scripts.

---

# 3. Build toolchain

- Scala 3.x: pin a concrete minor series in `build.sbt` (for example: `ThisBuild / scalaVersion := "3.3.x"`).
- Testing: choose a single test framework (MUnit or ScalaTest) and standardize across modules.
- Formatting: `scalafmt` (check + format).
- Linting: optional `scalafix` rules; default to `scalafmt` if you want minimal tooling.
- ZIO: use ZIO 2.x and pin the version in `libraryDependencies` for the `zio` module.
- Keep the purely-functional module dependency-free where possible so core logic compiles without effect libraries.

---

# 4. Source-of-truth extraction (literate by construction)

## 4.1 Region tagging in Scala

Mark extractable regions in Scala sources using explicit start/end markers, for example:

```scala
// > region: shamelessVerse
def verse(n: Int): String = n match
	case 0 => ...
	case 1 => ...
	case 2 => ...
	case k => ...
// < region: shamelessVerse
```

Rules:

- Always use `// > region: NAME` and `// < region: NAME` each on its own line.
- Keep regions small and composable.

## 4.2 Doc fences that point to regions

In your `docs/` Markdown, reference regions rather than pasting code, for example:

```md
<!-- snip: modules/functional/src/main/scala/bottles/Shameless.scala#region=shamelessVerse -->
```

The extractor script resolves the directive and replaces it with a fenced Scala block:

```md
```scala title="Shameless.scala: verse"
<inserted by extractor>
```
```

## 4.3 Ruby extractor (scripts/extract_snippets.rb)

Responsibilities:

- Parse Markdown files under `docs/` and `posts/` and find `<!-- snip: PATH#region=NAME -->` directives.
- Read the referenced Scala file, find the region markers, and inject the region contents inside a fenced code block.
- Validate that regions exist and fail CI if a reference cannot be resolved.
- Optionally write generated partials under `docs/_includes/` and/or render fully resolved Markdown in a build directory.

## 4.4 Ruby region checker (scripts/check_regions.rb)

- Walk all Scala sources and ensure every `// > region` has a matching `// < region`.
- Optionally assert that regions are used at least once in `docs/` or `posts/`.
- Fail CI on unbalanced or unused regions (configurable).

---

# 5. Design map: translating OOP chapters to FP/ZIO

Each chapter in `docs/` should receive two parallel treatments:

- Functional (Scala 3, pure functions + ADTs).
- Effect-oriented (ZIO 2, ZIOAppDefault, and ZLayer wiring).

Examples:

1. Shameless Green → minimal ADTs
	- Start from a very small, working pattern-match implementation.
	- Functional: pure total functions and exhaustive matches.
	- ZIO: wrap effectful concerns (I/O) with `ZLayer` and `ZIOAppDefault`.

2. TDD focus
	- Small, intention-revealing tests; assert outcomes, not implementation details.

3. Flocking Rules / refactorings
	- Show stepwise refactorings: function extraction, ADT refinement, pattern normalization.

4. Immutability & LSP
	- Use `opaque type` or newtype patterns for invariants like `BottleCount`.

5. Open/Closed
	- Add constructors/cases to extend behavior rather than changing callers.

6. Conditionals → data
	- Prefer ADTs + pattern matching; in ZIO, model behavior with services.

7. Factories spectrum
	- From pure constructors to ZLayer-based wiring.

8. Aesthetics & Law of Demeter
	- Emphasize narrow interfaces and composition over deep object graphs.

9. Testing strategy
	- Unit vs integration tests; fakes vs real layers; keep tests deterministic and fast.

---

# 6. Coding standards (for contributors and agents)

- Name things by domain meaning.
- Keep public surfaces small; prefer module-local helpers.
- Favor total functions and exhaustive matches; use `Option`/`Either` instead of throwing exceptions.
- Keep effects out of the functional module; implement effects in the `zio` module.
- Run `scalafmt` before committing; CI should enforce formatting.
- Do not hand-paste code into docs — always generate snippets from regions.

---

# 7. sbt layout & dependency graph

- Root aggregates `modules/*`.
- `shared`: domain types and test fixtures (minimal dependencies).
- `functional`: depends on `shared`.
- `zio`: depends on `shared` and adds ZIO dependencies.
- Cross-module tests ensure parity between implementations.

Example `build.sbt` sketch:

```scala
ThisBuild / scalaVersion := "3.3.x"

lazy val shared     = project.in(file("modules/shared"))
lazy val functional = project.in(file("modules/functional")).dependsOn(shared)
lazy val zio        = project.in(file("modules/zio")).dependsOn(shared)

libraryDependencies ++= Seq(
	// choose one test lib across all modules
	"org.scalameta" %% "munit" % "1.x" % Test
	// zio module may add:
	// "dev.zio" %% "zio" % "2.x",
	// "dev.zio" %% "zio-test" % "2.x" % Test
)
```

---

# 8. GitHub Actions (automation)

## 8.1 `ci.yml` (build & test; required for PRs)

- Trigger: `pull_request` on `modules/**`, `scripts/**`, `docs/**`.
- Jobs:
	- `format-check`: `scalafmt --check`.
	- `compile`: `sbt +compile` (all modules).
	- `test`: `sbt +test`.
	- `regions`: `ruby scripts/check_regions.rb`.
	- `extract-dry-run`: `ruby scripts/extract_snippets.rb --check`.

Required status checks should block merges until green.

## 8.2 `lint.yml` (optional)

- Trigger: manual or nightly.
- Purpose: run Scalafix or stricter linters if enabled.

## 8.3 `docs.yml` (generate docs site)

- Trigger: push to `main` that touches `modules/**` or `docs/**`.
- Steps:
	- Run extractor to render final `.md` files.
	- Build static site (for example: MkDocs or Jekyll with a Markdown theme).
	- Deploy to `gh-pages` or GitHub Pages.

## 8.4 `posts.yml` (draft social posts)

- Trigger: push to `main` touching `posts/**`.
- Steps:
	- Validate frontmatter with Ruby scripts (ensure required fields: `title`, `tags`, `platforms`, `snippet_refs`).
	- Inject resolved code snippets.
	- Attach artifacts (images) if present.
	- Emit an artifact JSON payload consumed by n8n for downstream posting.

## 8.5 `bot.yml` (PR review assistant, optional)

- Trigger: `pull_request`.
- Steps:
	- Run a Ruby script that checks region coverage and summarizes affected regions.
	- Post a review comment with a concise summary of what changed.

---

# 9. n8n agent workflows

n8n flows should be exported as JSON in `/n8n/` with a README explaining environment variables and secrets (X OAuth app, LinkedIn app, GitHub PAT).

### 9.1 review-agent.json

Flow outline:

1. GitHub → get PR diff (changed regions and chapters).
2. Fetch the rendered chapter (from CI artifact or `docs/`).
3. LLM (OpenAI or self-hosted): review diffs for clarity and style; avoid reproducing original book text.
4. GitHub → create a PR comment with summary and suggestions.
5. If labeled `ready-to-merge`, post a final checklist.

### 9.2 post-agent.json

Flow outline:

1. Download artifact (resolved post with code snippets).
2. LLM → produce two variants: an X (Twitter) version (<=280 chars) and a LinkedIn version (~700–1100 chars), each with a hook, a lesson, and a CTA.
3. Human-in-the-loop approval via n8n UI form.
4. Post to X using the X API.
5. Post to LinkedIn using the UGC API.
6. GitHub → create an issue comment linking to the published posts.

---

# 10. Content plan (chapters → posts)

Each chapter should yield:

- One long LinkedIn post: a mini-essay plus a small code diff (from a region) and the lesson learned.
- One short X post: a hook, one insight, and a link.

Suggested 10–12 week sequence:

1. Shameless Green in Scala 3: start simple to win.
2. Cost-effective tests: assert outcomes, not structure.
3. Flocking Rules: stepwise refactoring with total matches.
4. Immutability & Opaque Types: prevent invalid states.
5. Open/Closed via ADTs: add variants without touching callers.
6. From conditionals to data: the FP approach to polymorphism.
7. Factories → ZLayers: wiring effects explicitly.
8. Programming aesthetics: dependency inversion in FP/ZIO.
9. Law of Demeter (FP edition): minimize knowledge of strangers.
10. Better tests after better design: fewer, clearer, faster.

---

# 11. Example: core domain (shared)

- Types and invariants (for example):
	- `opaque type BottleCount = Int` (invariants: 0 ≤ n ≤ 99).
	- `enum VerseKind { case Zero, One, Two, Many(n: Int) }`.
- Rules and sequencing logic should live in pure functions (deterministic and total).
- Lyrics assembly should be separate from sequencing logic to aid testing and clarity.

---

# 12. Example: functional implementation

- `modules/functional/.../Shameless.scala`: a single `verse` function with an exhaustive match, initially simple.
- Refactor gradually: introduce ADTs and helpers only when the design needs them.
- Optional property tests: e.g., `verse(n).nonEmpty`, round-trip tests for sequence logic.

---

# 13. Example: ZIO 2 implementation

- Keep the pure logic in `shared` and reuse from `functional`.
- Wrap effects (printing, CLI args, file output) in `ZIOAppDefault` and `ZLayer` services, for example:

```scala
trait LyricsOut { def write(s: String): UIO[Unit] }
object LyricsOut { val console: ULayer[LyricsOut] = ZLayer.succeed(...) }
```

- Demonstrate the factories spectrum by swapping `LyricsOut` implementations via `ZLayer` without changing callers.

---

# 14. Tests

- Shared golden tests: compare the full song output (99 to 0) with an approved fixture.
- Functional vs ZIO parity tests: assert both implementations produce identical outputs for the same inputs.
- Keep tests focused on behavior, not internal implementation details.

---

# 15. Ruby scripts (sketches)

`scripts/extract_snippets.rb` (outline):

- Parse all Markdown for `<!-- snip: RELPATH#region=NAME -->` directives.
- Read `RELPATH` and extract the region between `// > region: NAME` and `// < region: NAME`.
- Output a fenced Scala block with an optional title attribute.
- Support `--check` mode to verify references without writing files.

`scripts/check_regions.rb`:

- Scan Scala sources and build a map of region starts/ends. Assert they are balanced and optionally warn on unused regions.

`scripts/post_pipeline.rb`:

- Read `posts/*.md` frontmatter.
- Inject snippets as above.
- Emit a JSON payload for n8n with title, text, platforms, tags, and URL.

All scripts should be written in Ruby by default (the repo uses Ruby for content tooling). Use only the standard library where possible; add small dependencies only when necessary.

---

# 16. Copilot prompts & repo prompts

Create `.github/COPILOT_PROMPTS.md` to guide AI agents. Examples:

- General: "Prefer small, total functions. Name by domain meaning. Don't anticipate abstractions. Keep effects out of `functional/`. Add ZIO services via ZLayer in `zio/`."
- Docs: "Never paste code into docs. Use snippet markers only. Explain why a refactor reduces future cost."
- Tests: "Assert outcomes, not structure. Prefer table-driven cases."

---

# 17. CI quality gates (PR must pass)

1. `scalafmt --check`
2. `sbt +test` (all modules)
3. `ruby scripts/check_regions.rb`
4. `ruby scripts/extract_snippets.rb --check`

---

# 18. First milestones (week-by-week)

**Week 1**

- Initialize repo, set up sbt and `scalafmt`.
- Add placeholder modules and Ruby script stubs.
- Add a first chapter with 1–2 snippet references and get CI passing for the extractor checks.

**Week 2**

- Implement Shameless Green (functional) and golden tests.
- Add a ZIO wrapper and docs for chapter 1.

**Weeks 3–4**

- Complete chapter 2 (tests philosophy) and chapter 3 (flocking rules).
- Introduce ADTs and opaque types where appropriate.

**Weeks 5–6**

- Complete chapters 4–6 (immutability/LSP, OCP, conditionals→data) and add ZIO services & layers.

**Weeks 7–8**

- Finish chapters 7–9 (aesthetic, Demeter, testing after design), stabilize, polish the site, and begin a weekly X/LinkedIn cadence.

---

# 19. Example post frontmatter

```yaml
---
title: "Shameless Green in Scala 3: start simple to win"
tags: ["scala", "fp", "design"]
platforms: ["x", "linkedin"]
snippet_refs:
	- path: modules/functional/src/main/scala/bottles/Shameless.scala
		region: shamelessVerse
cta_url: "https://github.com/you/99bottles-scala"
---
```

One thing the original book gets right: start with the simplest code that passes the tests. Use the extractor to insert small snippets and let n8n or the post pipeline prepare social variants for human review.

---

# 20. Success criteria

- All code shown in `docs/` and `posts/` is extracted from compiling sources.
- PRs are fast (under a few minutes), deterministic, and reproducible.
- Each chapter argues the cost/benefit of its refactor decisions.
- Readers can run both implementations locally and observe identical outputs; ZIO demonstrates composability of side effects without polluting core logic.

---